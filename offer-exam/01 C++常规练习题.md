[toc]

## 01、赋值运算符函数

解题四大要点：

```
- 是否把返回值的类型声明为该类型的引用，并且返回*this
- 是否把传入的参数类型声明为常量引用
- 是否判断传入参数和当前实例（*this）是否相同，并且是否是常量
- 是否释放实例自身已有的内存
```

```
// 初级程序员解法
Mystring& Mystring::operator=(const Mystring& str) {
	if (this == &str)
		return *this;   
        
	delete[]m_pData;
	m_pData = nullptr;	
	
	m_pData = new char[strlen(str.m_pData) + 1];
	strcpy(m_pData, str.m_pData);
	return *this;
}
```

推荐解法：

```
// 高级程序员解法
class CMyString {
public:
    CMyString(char* pData = nullptr);
    CMyString(const CMyString& str);
    ~CMyString();

    CMyString& operator=(const CMyString& str);

private:
    char* m_pData = nullptr;
};

// 构造函数
CMyString::CMyString(char* pData) {
    if (pData == nullptr) {
        m_pData = new char[1];
        *m_pData = '\0';
    } else {
        int nLength = strlen(pData);
        m_pData = new char[nLength + 1];
        strcpy(m_pData, pData);
    }
}

// 拷贝构造
CMyString::CMyString(const CMyString& str) {
    int nLength = strlen(str.m_pData);
    m_pData = new char[nLength + 1];
    strcpy(m_pData, str.m_pData);
}

// 析构函数
CMyString::~CMyString() {
    delete[] m_pData;
}

// 赋值运算
CMyString& CMyString::operator=(const CMyString& str) {
    if (this != &str) {
        CMyString strTemp(str);
        char* pTemp = strTemp.m_pData;
        strTemp.m_pData = m_pData;
        m_pData = pTemp;
    }
    return *this;
}
```



## 02、数组中重复的数字

* 给定一个长度为n，数值均在0~n-1内的数组，求任意一个重复的数字

### （1）解法一

```
# 利用下标和值对比的方法，不同的时候将当前值交换到当前值所在的下标上
2 3 1 0 2 5 3 ->
1 3 2 0 2 5 3 ->
3 1 2 0 2 5 3 ->
0 1 2 3 2 5 3 -> 当i=4时，p[4]==p[p[4]]，找到重复值
```

下面代码时间复杂度为O(n) 空间复杂度为O(1)

```
int g_nInvalidInput = false;

int FindDuplicate(int* pData, int nLength) {
    if (pData != nullptr && nLength > 0) {
        for (int i = 0; i < nLength; ++i) {
            while (pData[i] != i) {
                if (pData[i] == pData[pData[i]])
                    return pData[i];
                int nTemp = pData[pData[i]];
                pData[pData[i]] = pData[i];
                pData[i] = nTemp;
            }
        }
    }
    g_nInvalidInput = true;
    return 0;
}
```

### （2）解法二

* 给定一个长度为n + 1，数值均在1~n内的数组，求任意一个重复的数字
* 现在要求不能修改原数组空间，尽量写出高效代码
* 下面算法时间复杂度为O(nlogn) 以时间换取空间

```
int g_nInvalidInput = true;

int Calculate(const int* pData, int nLength, int nStart, int nEnd) {
    int nNum = 0;
    for (int i = 0; i < nLength; ++i) {
        if (pData[i] >= nStart && pData[i] <= nEnd)
            ++nNum;
    }
    return nNum;
}

int FindDuplicate(const int* pData, int nLength) {
    if (pData == nullptr && nLength < 1) {
        return 0;
    }

    int nStart = 1;
    int nEnd = nLength - 1;
    // 把1～7分为1～3和4～7,数组中数字在1～3之间的数目大于了3,就继续进入前半段二分法
    while (nStart <= nEnd) {
        int nMiddle = (nStart + nEnd) >> 1;
        int nNum = Calculate(pData, nLength, nStart, nMiddle);
        if (nStart == nEnd) {
            if (nNum > 1) {
                g_nInvalidInput = false;
                return nStart;
            }
            else
                break;
        }
        if (nNum > (nMiddle - nStart + 1))
            nEnd = nMiddle;
        else
            nStart = nMiddle + 1;
    }
    return 0;
}
```



## 03、横纵递增的二维数组中查找数字

```
# 比如有如下矩阵，可采用选取边角比较的方法，推荐选取右上角和左下角进行比较，这里选择左下角算法
1  2  8  9
2  4  9  12
4  7  10 13
6  8  11 15
```

```
bool IsExistNumber(int* pData, int nRows, int nColumns, int nNum) {
    if (pData == nullptr || nRows < 1 || nColumns < 1)
        return false;

    int nCurRow = 0;
    int nCurColumn = nColumns - 1;

    while (nCurRow < nRows && nCurColumn >= 0) {
        if (pData[nCurRow * nCurRow + nCurColumn] == nNum)
            return true;
        else if (pData[nCurRow * nCurRow + nCurColumn] > nNum)
            --nCurColumn;
        else
            ++nCurRow;
    }
    return false;
}
```



## 04、移除数组中的元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

时间O(n) 空间O(1)

```
class Solution {
public:
    int removeElement(std::vector<int>& nums, int val) {
        int start = 0;
        int end = nums.size();
        while (start < end) {
            if (nums[start] == val) {
                nums[start] = nums[end - 1];
                --end;
            } else
                ++start;
        }
        return start;
    }
};
```



## 05、十六进制转十进制

写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。

数据范围：保证结果在 1  < n < 2^31-1

注意本题有多组输入

```
#include <iostream>
using namespace std;

// 格式检测
bool CheckFormat(const string& str) {
    if (str[0] != '0' || str[1] != 'x')
        return false;
    for (int i = 2; i < str.size(); ++i) {
        if (isdigit(str[i])
            || (str[i] >= 'A' && str[i] <= 'F')
            || (str[i] >= 'a' && str[i] <= 'f'))
            continue;
        return false;
    }
    return true;
}

int main() {
    string str;
    while (cin >> str) {
        int preNum = 0;
        int curNum = 0;
        if (CheckFormat(str)) {
            for (int i = 2; i < str.size(); ++i) {
                if (str[i] >= 'A' && str[i] <= 'F')
                    curNum = 10 + str[i] - 'A';
                else if (str[i] >= 'a' && str[i] <= 'f')
                    curNum = 10 + str[i] - 'a';
                else
                    curNum = str[i] - '0';
                preNum = (preNum << 4) + curNum;
            }
            printf("%d\n", preNum);
        } else {
            printf("格式错误！\n");
        }
    }
    return 0;
}
```

